---
title: "RNA-seq tutorial - Data QC - Solutions"
format:
  html:
    embed-resources: true
    toc: true
    toc-location: left
    toc-depth: 3
    title-block-banner: "#00A7FF"
    code-tools: true
editor: visual
---

::: {.callout-tip collapse="true" icon="false" appearance="simple"}
### Solutions Exercise#1

1.  

```{r}
fc <- readRDS("featureCounts/mergedCounts.rds")
ka <- readRDS("Kallisto/mergedCounts.rds")

head(fc)
head(ka)
```

2.  The rows are the different. Kallisto quantifies on the transcript-level while FeatureCounts quantifies on the gene-level. For yeast however, alternative splicing is very rare, which is why there is a 1-to-1 mapping of transcripts to genes, hence why the matrices have the same number of rows. In the case of human or mouse, Kallisto's transcript dataframe would have to be accumulated to the gene-level.

```{r}
head(colnames(fc))
head(rownames(fc))

head(colnames(ka))
head(rownames(ka))

nrow(fc) == nrow(ka)
```

3.  The kallisto counts (est_count) are floating point numbers. This may become a problem when it comes time to load these counts for differential expression, since most of the available tools expect the counts to be discreet. In such cases we may have to round the counts to integers, or using packages like tximport.

4.  

```{r}
library(dplyr)
library(plotly)
toPlotF <- tibble::tibble(
  Sample=colnames(fc),
  `Read Counts`=colSums(fc)
)
p1 = plot_ly(toPlotF, x = ~Sample, y = ~`Read Counts`, type = "bar") %>% layout(title="Total reads FeatureCounts", yaxis = list(title = "Counts [Mio]"))

toPlotK <- tibble::tibble(
  Sample=colnames(ka),
  `Read Counts`=colSums(ka)
)
p2 = plot_ly(toPlotK, x = ~Sample, y = ~`Read Counts`, type = "bar") %>% layout(title="Total reads Kallisto", yaxis = list(title = "Counts [Mio]"))

p1
p2
```
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## Solutions Exercise #2

```{r}
#Load the data tables
fc <- readRDS("featureCounts/mergedCounts.rds")

# Define meta dataframe for later use
meta <- data.frame(
  Condition=as.factor(rep(c("Glucose", "GlycEth"), each=4)),
  row.names=c(paste0("G", 1:4), paste0("GE", 1:4))
)

# Define some general-use parameters for use later
countDirectoryToUse <- "featureCounts"
sigThresh <- 10
conditionColours <- scales::hue_pal()(length(unique(meta$Condition)))
names(conditionColours) <- unique(meta$Condition)
sampleColours <- conditionColours[meta$Condition]

isPresent <- fc > sigThresh
rawCountsFilt = fc[which(apply(isPresent, 1, any)), ]
rawCountsFilt = round(rawCountsFilt,0)

dds <- DESeq2::DESeqDataSetFromMatrix(countData=rawCountsFilt,
                                      colData=meta,
                                      design=~Condition)
vsd <- DESeq2::vst(dds)

# Extract normalized counts
vsdSE <- SummarizedExperiment::assay(vsd)
```

PCA

```{r, fig.width=10}
library(tibble)
# Run PCA
pcDat  <- prcomp(t(vsdSE), scale. = FALSE)

# Calculate explained variance
varExp <- (100*pcDat$sdev^2)/sum(pcDat$sdev^2)

# Store the explained variance of top 8 PCs
varExp_df <- data.frame(PC= paste0("PC",1:8),
                          varExp=varExp[1:8])

# Scree plot
varExp_df %>%
  ggplot(aes(x=PC,y=varExp, group=1)) +
  geom_point(colour="steelblue", size=4) +
  geom_col(fill="steelblue") +
  geom_line() + 
  theme_bw() + ylim(c(0,100))

#PCA plot
plot_ly(as.data.frame(pcDat$x), x=~PC1, y=~PC2, color=meta$Condition, colors="Set1",
        type="scatter", mode="markers") %>%
  layout(title="PCA Plot")
```

MDS

```{r}
library(tibble)
mds <- limma::plotMDS(vsdSE, plot=FALSE)
mdsOut <- mds$eigen.vectors[,1:3]
colnames(mdsOut) <- c("Leading logFC dim1", "Leading logFC dim2", 
                      "Leading logFC dim3")
toPlot <- cbind(meta %>% rownames_to_column("Sample"), mdsOut)
plot_ly(toPlot, x=~`Leading logFC dim1`, y=~`Leading logFC dim2`, z=~`Leading logFC dim3`, color=~Condition, colors="Set1", type='scatter3d', mode='markers+text', text=~Sample, textposition = "top right") %>%
  plotly::layout(title="Classical MDS", scene=list(xaxis=list(title = 'Leading logFC dim1'), yaxis = list(title = 'Leading logFC dim2'), zaxis = list(title = 'Leading logFC dim3')))
```

The following image and linked StackedOverflow post explains well the difference between the two methods.

![](https://i.stack.imgur.com/WvnU7.png){fig-alt="Visual explanation of the difference between PCA and MDS"}

### 
:::

::: {.callout-tip collapse="true" appearance="simple" icon="false"}
## Solutions Excercise #3

```{r}
library(pheatmap)
library(RColorBrewer)
# Pearson correlation plot 
pheatmap(
  mat               = cor(vsdSE, use="complete.obs"),
  treeheight_row    = 100,
  treeheight_col    = 100,
  cutree_rows       = 2, 
  cutree_cols       = 2,
  silent            = F,
  annotation_col    = meta,
  annotation_colors = list(Condition = conditionColours),
  color             = brewer.pal(n = 9, name = "Blues"),
  fontsize_row      = 12, 
  fontsize_col      = 12,
  display_numbers   = TRUE,
  fontsize_number   = 12)
```
:::
